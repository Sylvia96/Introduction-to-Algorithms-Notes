# 1. Introduction
Sorting -> running example
* Insertion sort 插入排序
* Merge sort 
## 1.1 Algrorithms
*input/output relationship*
### Sorting problem: 
*__Input__: A sequence of n numbers {a1,a2,...,an}.*

*__Output__: A permuation (reordering) {a1',a2',...,an'} of the input sequence such that a1'<=a2'<=...<=an'.*

__e.g.__ input {31,41,59,26,41,58} -> output {26,31,41,41,58,59}

### Insertion sort
*an efficient algotithm for sorting a small number of elements*

*compare A with each one existing*

> 5 __2__ 4 6 1 3

> 2 5 __4__ 6 1 3

> 2 4 5 __6__ 1 3

> 2 4 5 6 __1__ 3

> 1 2 4 5 6 __3__

> 1 2 3 4 5 6

## 1.2 Analyzing algorithms
*computational time*
### Analysis off insertion sort
* size of the input
* same size -> how nearly sorted they already are

*running time <-> size of input*

> Assume: each execution of the ith line takes time ci

> j=2,3,...,n (n=len[A])

> worst-case: T(n) = an^2+bn+c

> *rate of growth (order of growth)*: θ(n^2)

__We usually consider one algorithm to be more efficient than another if its worst-case running time has a lower order of growth.__

## 1.3 Designing algorithms
*divide-and-conquer* -> merge sort
> T(n) = θ(1) if n<=c; aT(n/b)+D(n)+C(n) otherwise.


